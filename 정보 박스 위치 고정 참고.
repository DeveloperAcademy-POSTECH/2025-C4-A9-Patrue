
import Charts
import SwiftUI

struct ChartTestView: View {
    // [month, day, timeline]
    var data: [Prediction]
    
    @State private var selectedDate: Date? = nil //ì„ íƒëœ ë‚ ì§œ
    
    var body: some View {
        VStack(alignment: .leading) {
            Chart {
                ForEach(data, id: \.id) { dataPoint in
                    //ì„  ê·¸ë˜í”„
                    LineMark(
                        x: .value("Time of day", dataPoint.asDate),
                        y: .value("Passengers", dataPoint.passengers)
                    )
                    .interpolationMethod(.linear)
                    .foregroundStyle(.green)
                    .lineStyle(StrokeStyle(lineWidth: 4))
                    .alignsMarkStylesWithPlotArea()
                    //ì™¸ë¶€ ì´ˆë¡ìƒ‰ í°ì 
                    PointMark(
                        x: .value("Time of day", dataPoint.asDate),
                        y: .value("Passengers", dataPoint.passengers)
                    )
                    .symbolSize(CGSize(width: 18, height: 18))
                    .foregroundStyle(.green)
                    .accessibilityHidden(true)
                    //ë‚´ë¶€ í°ìƒ‰ ì 
                    PointMark(
                        x: .value("Time of day", dataPoint.asDate),
                        y: .value("Passengers", dataPoint.passengers)
                    )
                    .symbolSize(CGSize(width: 8, height: 8))
                    .foregroundStyle(.white)
                    //                    .accessibilityLabel("Now")
                }
                // ì„ íƒëœ ì‹œì  ì´ì „ì„ ë§ˆìŠ¤í‚¹
                if let selectedDate = selectedDate,
                   let first = data.first,
                   let highlighted = data.min(by: { abs($0.asDate.timeIntervalSince(selectedDate)) < abs($1.asDate.timeIntervalSince(selectedDate)) }) {
                    //ë£° ë§ˆí¬ ì´ì „ ìƒ‰ìƒ ì–´ë‘¡ê²Œ ì²˜ë¦¬
                    RectangleMark(
                        xStart: .value("ì‹œì‘", first.asDate), //ë§¨ ì²˜ìŒì‹œê°„
                        xEnd: .value("ì„ íƒëœ ì‹œê°", highlighted.asDate) // ì„ íƒëœ ì§ì „ ì‹œê°„
                    )
                    .foregroundStyle(Color.black.opacity(0.08))
                    .zIndex(-1)
                
                    //ë£° ë§ˆí¬
                    RuleMark(x: .value("ì„ íƒëœ ì‹œê°„", highlighted.asDate))
                        .foregroundStyle(Color.black)
                        .lineStyle(StrokeStyle(lineWidth: 2))
                    //ë£° ë§ˆí¬ ë‚´ë¶€ ìƒ‰ê¹” ì´ˆë¡ìƒ‰ìœ¼ë¡œ ì±„ìš°ê¸°
                    PointMark(
                        x: .value("ì„ íƒëœ ì‹œê°„", highlighted.asDate),
                        y: .value("ìŠ¹ê°ìˆ˜", highlighted.passengers)
                    )
                    .symbolSize(CGSize(width: 14, height: 14))
                    .foregroundStyle(Color.green)

                    
                }
            }
            .chartOverlay { proxy in
                GeometryReader { geo in
                    ZStack {
                        // ğŸ¯ ì œìŠ¤ì²˜ ê°ì§€ ì˜ì—­
                        Rectangle()
                            .fill(.clear)
                            .contentShape(Rectangle())
                            .gesture(
                                DragGesture(minimumDistance: 0)
                                    .onChanged { value in
                                        let origin = geo[proxy.plotAreaFrame].origin
                                        let locationX = value.location.x - origin.x

                                        if let date: Date = proxy.value(atX: locationX) {
                                            self.selectedDate = date
                                        }
                                    }
                            )

                        // âœ… ìƒíƒœ ë°•ìŠ¤ (Xì¶•ë§Œ ë”°ë¼ë‹¤ë‹˜, Yì¶•ì€ plot ìƒë‹¨ ê³ ì •)
                        if let selectedDate = selectedDate,
                           let highlighted = data.min(by: { abs($0.asDate.timeIntervalSince(selectedDate)) < abs($1.asDate.timeIntervalSince(selectedDate)) }),
                           let xPosition = proxy.position(forX: highlighted.asDate) {

                            let plotFrame = geo[proxy.plotAreaFrame]
                            let boxWidth: CGFloat = 70
                            let safeX = min(max(xPosition + plotFrame.origin.x, boxWidth / 2), plotFrame.maxX - boxWidth / 2)

                            VStack(spacing: 4) {
                                Text(highlighted.asDate, format: Date.FormatStyle().hour().minute())
                                    .font(.caption2)
                                    .foregroundColor(.black)

                                Text("\(highlighted.passengers)ëª…")
                                    .font(.subheadline)
                                    .foregroundColor(.black)
                            }
                            .frame(width: boxWidth)
                            .padding(6)
                            .background(Color.white)
                            .cornerRadius(8)
                            .position(
                                x: safeX,
                                y: plotFrame.minY - 20
                            )
                        }
                    }
                }
            }

            
            
            .frame(height: 250) // ê·¸ë˜í”„ ë†’ì´ 200pxë¡œ ì„¤ì •

            

            .chartYScale(range: .plotDimension(padding: 2))
            .chartYAxis {
                AxisMarks(
                    values: [0, 5000, 10000, 15000, 20000]
                ) {
                    AxisGridLine()
                }
                
            }
        }
        .padding()
        .onAppear {
            print("\(data[19].month)-\(data[19].day)-\(data[19].timeline)-\(data[19].passengers)")
        }
    }
    
    func descriptionForCongestion(_ passengers: Int) -> String {
        switch passengers {
        case 0 ... 5000: return "Low"
        case 5001 ... 10000: return "Moderate"
        case 10001 ... 15000: return "High"
        default: return "Extreme"
        }
    }
}
